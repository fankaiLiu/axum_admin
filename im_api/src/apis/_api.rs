/*
 * 采购系统
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct DefaultApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> DefaultApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> DefaultApiClient<C> {
        DefaultApiClient {
            configuration,
        }
    }
}

pub trait DefaultApi {
    fn account_check(&self, token: &str, base_info_account_check_req: Option<crate::models::BaseInfoAccountCheckReq>) -> Box<dyn Future<Item = crate::models::BaseInfoAccountCheckResp, Error = Error<serde_json::Value>>>;
    fn add_black(&self, token: &str, base_info_add_blacklist_req: Option<crate::models::BaseInfoAddBlacklistReq>) -> Box<dyn Future<Item = crate::models::BaseInfoAddBlacklistResp, Error = Error<serde_json::Value>>>;
    fn add_friend(&self, token: &str, base_info_add_friend_req: Option<crate::models::BaseInfoAddFriendReq>) -> Box<dyn Future<Item = crate::models::BaseInfoAddFriendResp, Error = Error<serde_json::Value>>>;
    fn add_friend_response(&self, token: &str, base_info_add_friend_response_req: Option<crate::models::BaseInfoAddFriendResponseReq>) -> Box<dyn Future<Item = crate::models::BaseInfoAddFriendResponseResp, Error = Error<serde_json::Value>>>;
    fn application_group_response(&self, token: &str, base_info_application_group_response_req: Option<crate::models::BaseInfoApplicationGroupResponseReq>) -> Box<dyn Future<Item = crate::models::BaseInfoApplicationGroupResponseResp, Error = Error<serde_json::Value>>>;
    fn cancel_mute_group(&self, token: &str, base_info_cancel_mute_group_req: Option<crate::models::BaseInfoCancelMuteGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCancelMuteGroupResp, Error = Error<serde_json::Value>>>;
    fn cancel_mute_group_member(&self, token: &str, base_info_cancel_mute_group_member_req: Option<crate::models::BaseInfoCancelMuteGroupMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCancelMuteGroupMemberResp, Error = Error<serde_json::Value>>>;
    fn clear_msg(&self, token: &str, base_info_clean_up_msg_req: Option<crate::models::BaseInfoCleanUpMsgReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCleanUpMsgResp, Error = Error<serde_json::Value>>>;
    fn comment_one_work_moment(&self, token: &str, base_info_comment_one_work_moment_req: Option<crate::models::BaseInfoCommentOneWorkMomentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCommentOneWorkMomentResp, Error = Error<serde_json::Value>>>;
    fn create_department(&self, token: &str, base_info_create_department_req: Option<crate::models::BaseInfoCreateDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateDepartmentResp, Error = Error<serde_json::Value>>>;
    fn create_department_member(&self, token: &str, base_info_create_department_member_req: Option<crate::models::BaseInfoCreateDepartmentMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateDepartmentMemberResp, Error = Error<serde_json::Value>>>;
    fn create_group(&self, token: &str, base_info_create_group_req: Option<crate::models::BaseInfoCreateGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateGroupResp, Error = Error<serde_json::Value>>>;
    fn create_one_work_moment(&self, token: &str, base_info_create_one_work_moment_req: Option<crate::models::BaseInfoCreateOneWorkMomentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateOneWorkMomentResp, Error = Error<serde_json::Value>>>;
    fn create_organization_user(&self, token: &str, base_info_create_organization_user_req: Option<crate::models::BaseInfoCreateOrganizationUserReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateOrganizationUserResp, Error = Error<serde_json::Value>>>;
    fn create_tag(&self, token: &str, base_info_create_tag_req: Option<crate::models::BaseInfoCreateTagReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateTagResp, Error = Error<serde_json::Value>>>;
    fn del_msg(&self, token: &str, base_info_del_msg_req: Option<crate::models::BaseInfoDelMsgReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDelMsgResp, Error = Error<serde_json::Value>>>;
    fn delete_comment(&self, token: &str, base_info_delete_comment_req: Option<crate::models::BaseInfoDeleteCommentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteCommentResp, Error = Error<serde_json::Value>>>;
    fn delete_department(&self, token: &str, base_info_delete_department_req: Option<crate::models::BaseInfoDeleteDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteDepartmentResp, Error = Error<serde_json::Value>>>;
    fn delete_friend(&self, token: &str, base_info_delete_friend_req: Option<crate::models::BaseInfoDeleteFriendReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteFriendResp, Error = Error<serde_json::Value>>>;
    fn delete_one_work_moment(&self, token: &str, base_info_delete_one_work_moment_req: Option<crate::models::BaseInfoDeleteOneWorkMomentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteOneWorkMomentResp, Error = Error<serde_json::Value>>>;
    fn delete_organization_user(&self, token: &str, base_info_delete_organization_user_req: Option<crate::models::BaseInfoDeleteOrganizationUserReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteOrganizationUserResp, Error = Error<serde_json::Value>>>;
    fn delete_tag(&self, token: &str, base_info_delete_tag_req: Option<crate::models::BaseInfoDeleteTagReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteTagResp, Error = Error<serde_json::Value>>>;
    fn delete_user_in_department(&self, token: &str, base_info_delete_user_in_department_req: Option<crate::models::BaseInfoDeleteUserInDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteUserInDepartmentResp, Error = Error<serde_json::Value>>>;
    fn dismiss_group(&self, token: &str, base_info_dismiss_group_req: Option<crate::models::BaseInfoDismissGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDismissGroupResp, Error = Error<serde_json::Value>>>;
    fn force_logout(&self, token: &str, base_info_force_logout_req: Option<crate::models::BaseInfoForceLogoutReq>) -> Box<dyn Future<Item = crate::models::BaseInfoForceLogoutResp, Error = Error<serde_json::Value>>>;
    fn get_all_conversations(&self, token: &str, base_info_get_all_conversations_req: Option<crate::models::BaseInfoGetAllConversationsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetAllConversationsResp, Error = Error<serde_json::Value>>>;
    fn get_all_users_uid(&self, token: &str, base_info_get_all_users_uid_req: Option<crate::models::BaseInfoGetAllUsersUidReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetAllUsersUidResp, Error = Error<serde_json::Value>>>;
    fn get_blacklist(&self, token: &str, base_info_get_black_list_req: Option<crate::models::BaseInfoGetBlackListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetBlackListResp, Error = Error<serde_json::Value>>>;
    fn get_conversation(&self, token: &str, base_info_get_conversation_req: Option<crate::models::BaseInfoGetConversationReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetConversationResp, Error = Error<serde_json::Value>>>;
    fn get_conversations(&self, token: &str, base_info_get_conversations_req: Option<crate::models::BaseInfoGetConversationsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetConversationsResp, Error = Error<serde_json::Value>>>;
    fn get_department_member(&self, token: &str, base_info_get_department_member_req: Option<crate::models::BaseInfoGetDepartmentMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetDepartmentMemberResp, Error = Error<serde_json::Value>>>;
    fn get_friend_apply_list(&self, token: &str, base_info_get_friend_apply_list_req: Option<crate::models::BaseInfoGetFriendApplyListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetFriendApplyListResp, Error = Error<serde_json::Value>>>;
    fn get_friend_list(&self, token: &str, base_info_get_friend_list_req: Option<crate::models::BaseInfoGetFriendListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetFriendListResp, Error = Error<serde_json::Value>>>;
    fn get_group_all_member_list(&self, token: &str, base_info_get_group_all_member_req: Option<crate::models::BaseInfoGetGroupAllMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupAllMemberResp, Error = Error<serde_json::Value>>>;
    fn get_group_members_info(&self, token: &str, base_info_get_group_members_info_req: Option<crate::models::BaseInfoGetGroupMembersInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupMembersInfoResp, Error = Error<serde_json::Value>>>;
    fn get_groups_info(&self, token: &str, base_info_get_group_info_req: Option<crate::models::BaseInfoGetGroupInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupInfoResp, Error = Error<serde_json::Value>>>;
    fn get_joined_group_list(&self, token: &str, base_info_get_joined_group_list_req: Option<crate::models::BaseInfoGetJoinedGroupListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetJoinedGroupListResp, Error = Error<serde_json::Value>>>;
    fn get_recv_group_application_list(&self, token: &str, base_info_get_group_application_list_req: Option<crate::models::BaseInfoGetGroupApplicationListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupApplicationListResp, Error = Error<serde_json::Value>>>;
    fn get_self_friend_apply_list(&self, token: &str, base_info_get_self_apply_list_req: Option<crate::models::BaseInfoGetSelfApplyListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetSelfApplyListResp, Error = Error<serde_json::Value>>>;
    fn get_self_user_info(&self, token: &str, base_info_get_self_user_info_req: Option<crate::models::BaseInfoGetSelfUserInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetSelfUserInfoResp, Error = Error<serde_json::Value>>>;
    fn get_sub_department(&self, token: &str, base_info_get_sub_department_req: Option<crate::models::BaseInfoGetSubDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetSubDepartmentResp, Error = Error<serde_json::Value>>>;
    fn get_tag_send_logs(&self, token: &str, base_info_get_tag_send_logs_req: Option<crate::models::BaseInfoGetTagSendLogsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetTagSendLogsResp, Error = Error<serde_json::Value>>>;
    fn get_user_friend_work_moments(&self, token: &str, base_info_get_user_friend_work_moments_req: Option<crate::models::BaseInfoGetUserFriendWorkMomentsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserFriendWorkMomentsResp, Error = Error<serde_json::Value>>>;
    fn get_user_in_department(&self, token: &str, base_info_get_user_in_department_req: Option<crate::models::BaseInfoGetUserInDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserInDepartmentResp, Error = Error<serde_json::Value>>>;
    fn get_user_req_group_application_list(&self, token: &str, base_info_get_user_req_group_application_list_req: Option<crate::models::BaseInfoGetUserReqGroupApplicationListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupApplicationListResp, Error = Error<serde_json::Value>>>;
    fn get_user_tag_by_id(&self, token: &str, base_info_get_user_tag_by_id_req: Option<crate::models::BaseInfoGetUserTagByIdReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserTagByIdResp, Error = Error<serde_json::Value>>>;
    fn get_user_tags(&self, token: &str, base_info_get_user_tags_req: Option<crate::models::BaseInfoGetUserTagsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserTagsResp, Error = Error<serde_json::Value>>>;
    fn get_user_work_moments(&self, token: &str, base_info_get_user_work_moments_req: Option<crate::models::BaseInfoGetUserWorkMomentsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserWorkMomentsResp, Error = Error<serde_json::Value>>>;
    fn get_users_info(&self, token: &str, base_info_get_users_info_req: Option<crate::models::BaseInfoGetUsersInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUsersInfoResp, Error = Error<serde_json::Value>>>;
    fn get_users_online_status(&self, token: &str, base_info_get_users_online_status_req: Option<crate::models::BaseInfoGetUsersOnlineStatusReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUsersOnlineStatusResp, Error = Error<serde_json::Value>>>;
    fn get_work_moment_by_id(&self, token: &str, base_info_get_work_moment_by_id_req: Option<crate::models::BaseInfoGetWorkMomentByIdReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetWorkMomentByIdResp, Error = Error<serde_json::Value>>>;
    fn import_friend(&self, token: &str, base_info_import_friend_req: Option<crate::models::BaseInfoImportFriendReq>) -> Box<dyn Future<Item = crate::models::BaseInfoImportFriendResp, Error = Error<serde_json::Value>>>;
    fn invite_user_to_group(&self, token: &str, base_info_invite_user_to_group_req: Option<crate::models::BaseInfoInviteUserToGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoInviteUserToGroupResp, Error = Error<serde_json::Value>>>;
    fn is_friend(&self, token: &str, base_info_is_friend_req: Option<crate::models::BaseInfoIsFriendReq>) -> Box<dyn Future<Item = crate::models::BaseInfoIsFriendResp, Error = Error<serde_json::Value>>>;
    fn join_group(&self, token: &str, base_info_join_group_req: Option<crate::models::BaseInfoJoinGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoJoinGroupResp, Error = Error<serde_json::Value>>>;
    fn kick_group_member(&self, token: &str, base_info_kick_group_member_req: Option<crate::models::BaseInfoKickGroupMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoKickGroupMemberResp, Error = Error<serde_json::Value>>>;
    fn like_one_work_moment(&self, token: &str, base_info_like_one_work_moment_req: Option<crate::models::BaseInfoLikeOneWorkMomentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoLikeOneWorkMomentResp, Error = Error<serde_json::Value>>>;
    // fn management_batch_send_msg(&self, token: &str, UNKNOWN_BASE_TYPE: Option<crate::models::UNKNOWN_BASE_TYPE>) -> Box<dyn Future<Item = crate::models::BaseInfoManagementBatchSendMsgReq, Error = Error<serde_json::Value>>>;
    // fn management_send_msg(&self, token: &str, UNKNOWN_BASE_TYPE: Option<crate::models::UNKNOWN_BASE_TYPE>) -> Box<dyn Future<Item = crate::models::BaseInfoManagementSendMsgResp, Error = Error<serde_json::Value>>>;
    fn minio_upload_file(&self, token: &str, file: std::path::PathBuf, file_type: i32, operation_id: &str) -> Box<dyn Future<Item = crate::models::BaseInfoMinioUploadFileResp, Error = Error<serde_json::Value>>>;
    fn mute_group(&self, token: &str, base_info_mute_group_req: Option<crate::models::BaseInfoMuteGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoMuteGroupResp, Error = Error<serde_json::Value>>>;
    fn mute_group_member(&self, token: &str, base_info_mute_group_member_req: Option<crate::models::BaseInfoMuteGroupMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDismissGroupResp, Error = Error<serde_json::Value>>>;
    fn parse_token(&self, token: &str, base_info_parse_token_req: Option<crate::models::BaseInfoParseTokenReq>) -> Box<dyn Future<Item = crate::models::BaseInfoParseTokenResp, Error = Error<serde_json::Value>>>;
    fn quit_group(&self, token: &str, base_info_quit_group_req: Option<crate::models::BaseInfoQuitGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoQuitGroupResp, Error = Error<serde_json::Value>>>;
    fn remove_black(&self, token: &str, base_info_remove_black_list_req: Option<crate::models::BaseInfoRemoveBlackListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoRemoveBlackListResp, Error = Error<serde_json::Value>>>;
    fn send_msg2_tag(&self, token: &str, base_info_send_msg2_tag_req: Option<crate::models::BaseInfoSendMsg2TagReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSendMsg2TagResp, Error = Error<serde_json::Value>>>;
    fn set_friend_remark(&self, token: &str, base_info_set_friend_remark_req: Option<crate::models::BaseInfoSetFriendRemarkReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetFriendRemarkResp, Error = Error<serde_json::Value>>>;
    fn set_global_recv_message_opt(&self, token: &str, base_info_set_global_recv_message_opt_req: Option<crate::models::BaseInfoSetGlobalRecvMessageOptReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetGlobalRecvMessageOptResp, Error = Error<serde_json::Value>>>;
    fn set_group_info(&self, token: &str, base_info_set_group_info_req: Option<crate::models::BaseInfoSetGroupInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetGroupInfoResp, Error = Error<serde_json::Value>>>;
    fn set_group_member_info(&self, token: &str, base_info_set_group_member_info_req: Option<crate::models::BaseInfoSetGroupMemberInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetGroupMemberInfoResp, Error = Error<serde_json::Value>>>;
    fn set_tag(&self, token: &str, base_info_set_tag_req: Option<crate::models::BaseInfoSetTagReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetTagResp, Error = Error<serde_json::Value>>>;
    fn transfer_group_owner(&self, token: &str, base_info_transfer_group_owner_req: Option<crate::models::BaseInfoTransferGroupOwnerReq>) -> Box<dyn Future<Item = crate::models::BaseInfoTransferGroupOwnerResp, Error = Error<serde_json::Value>>>;
    fn update_department(&self, token: &str, base_info_update_department_req: Option<crate::models::BaseInfoUpdateDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUpdateDepartmentResp, Error = Error<serde_json::Value>>>;
    fn update_organization_user(&self, token: &str, base_info_update_organization_user_req: Option<crate::models::BaseInfoUpdateOrganizationUserReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUpdateOrganizationUserResp, Error = Error<serde_json::Value>>>;
    fn update_user_in_department(&self, token: &str, base_info_update_user_in_department_req: Option<crate::models::BaseInfoUpdateUserInDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUpdateUserInDepartmentResp, Error = Error<serde_json::Value>>>;
    fn update_user_info(&self, token: &str, base_info_update_self_user_info_req: Option<crate::models::BaseInfoUpdateSelfUserInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUpdateUserInfoResp, Error = Error<serde_json::Value>>>;
    fn user_register(&self, base_info_user_register_req: Option<crate::models::BaseInfoUserRegisterReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUserRegisterResp, Error = Error<serde_json::Value>>>;
    fn user_token(&self, base_info_user_token_req: Option<crate::models::BaseInfoUserTokenReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUserTokenResp, Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>DefaultApi for DefaultApiClient<C> {
    fn account_check(&self, token: &str, base_info_account_check_req: Option<crate::models::BaseInfoAccountCheckReq>) -> Box<dyn Future<Item = crate::models::BaseInfoAccountCheckResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/user/account_check".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_account_check_req);

        req.execute(self.configuration.borrow())
    }

    fn add_black(&self, token: &str, base_info_add_blacklist_req: Option<crate::models::BaseInfoAddBlacklistReq>) -> Box<dyn Future<Item = crate::models::BaseInfoAddBlacklistResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/add_black".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_add_blacklist_req);

        req.execute(self.configuration.borrow())
    }

    fn add_friend(&self, token: &str, base_info_add_friend_req: Option<crate::models::BaseInfoAddFriendReq>) -> Box<dyn Future<Item = crate::models::BaseInfoAddFriendResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/add_friend".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_add_friend_req);

        req.execute(self.configuration.borrow())
    }

    fn add_friend_response(&self, token: &str, base_info_add_friend_response_req: Option<crate::models::BaseInfoAddFriendResponseReq>) -> Box<dyn Future<Item = crate::models::BaseInfoAddFriendResponseResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/add_friend_response".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_add_friend_response_req);

        req.execute(self.configuration.borrow())
    }

    fn application_group_response(&self, token: &str, base_info_application_group_response_req: Option<crate::models::BaseInfoApplicationGroupResponseReq>) -> Box<dyn Future<Item = crate::models::BaseInfoApplicationGroupResponseResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/group_application_response".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_application_group_response_req);

        req.execute(self.configuration.borrow())
    }

    fn cancel_mute_group(&self, token: &str, base_info_cancel_mute_group_req: Option<crate::models::BaseInfoCancelMuteGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCancelMuteGroupResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/cancel_mute_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_cancel_mute_group_req);

        req.execute(self.configuration.borrow())
    }

    fn cancel_mute_group_member(&self, token: &str, base_info_cancel_mute_group_member_req: Option<crate::models::BaseInfoCancelMuteGroupMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCancelMuteGroupMemberResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/cancel_mute_group_member".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_cancel_mute_group_member_req);

        req.execute(self.configuration.borrow())
    }

    fn clear_msg(&self, token: &str, base_info_clean_up_msg_req: Option<crate::models::BaseInfoCleanUpMsgReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCleanUpMsgResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/msg/clear_msg".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_clean_up_msg_req);

        req.execute(self.configuration.borrow())
    }

    fn comment_one_work_moment(&self, token: &str, base_info_comment_one_work_moment_req: Option<crate::models::BaseInfoCommentOneWorkMomentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCommentOneWorkMomentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/comment_one_work_moment".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_comment_one_work_moment_req);

        req.execute(self.configuration.borrow())
    }

    fn create_department(&self, token: &str, base_info_create_department_req: Option<crate::models::BaseInfoCreateDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateDepartmentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/create_department".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_create_department_req);

        req.execute(self.configuration.borrow())
    }

    fn create_department_member(&self, token: &str, base_info_create_department_member_req: Option<crate::models::BaseInfoCreateDepartmentMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateDepartmentMemberResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/create_department_member".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_create_department_member_req);

        req.execute(self.configuration.borrow())
    }

    fn create_group(&self, token: &str, base_info_create_group_req: Option<crate::models::BaseInfoCreateGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateGroupResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/create_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_create_group_req);

        req.execute(self.configuration.borrow())
    }

    fn create_one_work_moment(&self, token: &str, base_info_create_one_work_moment_req: Option<crate::models::BaseInfoCreateOneWorkMomentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateOneWorkMomentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/create_one_work_moment".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_create_one_work_moment_req);

        req.execute(self.configuration.borrow())
    }

    fn create_organization_user(&self, token: &str, base_info_create_organization_user_req: Option<crate::models::BaseInfoCreateOrganizationUserReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateOrganizationUserResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/create_organization_user".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_create_organization_user_req);

        req.execute(self.configuration.borrow())
    }

    fn create_tag(&self, token: &str, base_info_create_tag_req: Option<crate::models::BaseInfoCreateTagReq>) -> Box<dyn Future<Item = crate::models::BaseInfoCreateTagResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/create_tag".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_create_tag_req);

        req.execute(self.configuration.borrow())
    }

    fn del_msg(&self, token: &str, base_info_del_msg_req: Option<crate::models::BaseInfoDelMsgReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDelMsgResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/msg/del_msg".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_del_msg_req);

        req.execute(self.configuration.borrow())
    }

    fn delete_comment(&self, token: &str, base_info_delete_comment_req: Option<crate::models::BaseInfoDeleteCommentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteCommentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/delete_comment".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_delete_comment_req);

        req.execute(self.configuration.borrow())
    }

    fn delete_department(&self, token: &str, base_info_delete_department_req: Option<crate::models::BaseInfoDeleteDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteDepartmentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/delete_department".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_delete_department_req);

        req.execute(self.configuration.borrow())
    }

    fn delete_friend(&self, token: &str, base_info_delete_friend_req: Option<crate::models::BaseInfoDeleteFriendReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteFriendResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/delete_friend".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_delete_friend_req);

        req.execute(self.configuration.borrow())
    }

    fn delete_one_work_moment(&self, token: &str, base_info_delete_one_work_moment_req: Option<crate::models::BaseInfoDeleteOneWorkMomentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteOneWorkMomentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/delete_one_work_moment".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_delete_one_work_moment_req);

        req.execute(self.configuration.borrow())
    }

    fn delete_organization_user(&self, token: &str, base_info_delete_organization_user_req: Option<crate::models::BaseInfoDeleteOrganizationUserReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteOrganizationUserResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/delete_organization_user".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_delete_organization_user_req);

        req.execute(self.configuration.borrow())
    }

    fn delete_tag(&self, token: &str, base_info_delete_tag_req: Option<crate::models::BaseInfoDeleteTagReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteTagResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/delete_tag".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_delete_tag_req);

        req.execute(self.configuration.borrow())
    }

    fn delete_user_in_department(&self, token: &str, base_info_delete_user_in_department_req: Option<crate::models::BaseInfoDeleteUserInDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDeleteUserInDepartmentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/delete_user_in_department".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_delete_user_in_department_req);

        req.execute(self.configuration.borrow())
    }

    fn dismiss_group(&self, token: &str, base_info_dismiss_group_req: Option<crate::models::BaseInfoDismissGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDismissGroupResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/dismiss_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_dismiss_group_req);

        req.execute(self.configuration.borrow())
    }

    fn force_logout(&self, token: &str, base_info_force_logout_req: Option<crate::models::BaseInfoForceLogoutReq>) -> Box<dyn Future<Item = crate::models::BaseInfoForceLogoutResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/auth/force_logout".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_force_logout_req);

        req.execute(self.configuration.borrow())
    }

    fn get_all_conversations(&self, token: &str, base_info_get_all_conversations_req: Option<crate::models::BaseInfoGetAllConversationsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetAllConversationsResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/msg/get_all_conversations".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_all_conversations_req);

        req.execute(self.configuration.borrow())
    }

    fn get_all_users_uid(&self, token: &str, base_info_get_all_users_uid_req: Option<crate::models::BaseInfoGetAllUsersUidReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetAllUsersUidResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/user/get_all_users_uid".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_all_users_uid_req);

        req.execute(self.configuration.borrow())
    }

    fn get_blacklist(&self, token: &str, base_info_get_black_list_req: Option<crate::models::BaseInfoGetBlackListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetBlackListResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/get_black_list".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_black_list_req);

        req.execute(self.configuration.borrow())
    }

    fn get_conversation(&self, token: &str, base_info_get_conversation_req: Option<crate::models::BaseInfoGetConversationReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetConversationResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/msg/get_conversation".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_conversation_req);

        req.execute(self.configuration.borrow())
    }

    fn get_conversations(&self, token: &str, base_info_get_conversations_req: Option<crate::models::BaseInfoGetConversationsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetConversationsResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/msg/get_conversations".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_conversations_req);

        req.execute(self.configuration.borrow())
    }

    fn get_department_member(&self, token: &str, base_info_get_department_member_req: Option<crate::models::BaseInfoGetDepartmentMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetDepartmentMemberResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/get_department_member".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_department_member_req);

        req.execute(self.configuration.borrow())
    }

    fn get_friend_apply_list(&self, token: &str, base_info_get_friend_apply_list_req: Option<crate::models::BaseInfoGetFriendApplyListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetFriendApplyListResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/get_friend_apply_list".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_friend_apply_list_req);

        req.execute(self.configuration.borrow())
    }

    fn get_friend_list(&self, token: &str, base_info_get_friend_list_req: Option<crate::models::BaseInfoGetFriendListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetFriendListResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/get_friend_list".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_friend_list_req);

        req.execute(self.configuration.borrow())
    }

    fn get_group_all_member_list(&self, token: &str, base_info_get_group_all_member_req: Option<crate::models::BaseInfoGetGroupAllMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupAllMemberResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/get_group_all_member_list".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_group_all_member_req);

        req.execute(self.configuration.borrow())
    }

    fn get_group_members_info(&self, token: &str, base_info_get_group_members_info_req: Option<crate::models::BaseInfoGetGroupMembersInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupMembersInfoResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/get_group_members_info".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_group_members_info_req);

        req.execute(self.configuration.borrow())
    }

    fn get_groups_info(&self, token: &str, base_info_get_group_info_req: Option<crate::models::BaseInfoGetGroupInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupInfoResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/get_groups_info".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_group_info_req);

        req.execute(self.configuration.borrow())
    }

    fn get_joined_group_list(&self, token: &str, base_info_get_joined_group_list_req: Option<crate::models::BaseInfoGetJoinedGroupListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetJoinedGroupListResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/get_joined_group_list".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_joined_group_list_req);

        req.execute(self.configuration.borrow())
    }

    fn get_recv_group_application_list(&self, token: &str, base_info_get_group_application_list_req: Option<crate::models::BaseInfoGetGroupApplicationListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupApplicationListResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/get_recv_group_applicationList".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_group_application_list_req);

        req.execute(self.configuration.borrow())
    }

    fn get_self_friend_apply_list(&self, token: &str, base_info_get_self_apply_list_req: Option<crate::models::BaseInfoGetSelfApplyListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetSelfApplyListResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/get_self_friend_apply_list".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_self_apply_list_req);

        req.execute(self.configuration.borrow())
    }

    fn get_self_user_info(&self, token: &str, base_info_get_self_user_info_req: Option<crate::models::BaseInfoGetSelfUserInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetSelfUserInfoResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/user/get_self_user_info".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_self_user_info_req);

        req.execute(self.configuration.borrow())
    }

    fn get_sub_department(&self, token: &str, base_info_get_sub_department_req: Option<crate::models::BaseInfoGetSubDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetSubDepartmentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/get_sub_department".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_sub_department_req);

        req.execute(self.configuration.borrow())
    }

    fn get_tag_send_logs(&self, token: &str, base_info_get_tag_send_logs_req: Option<crate::models::BaseInfoGetTagSendLogsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetTagSendLogsResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/get_send_tag_log".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_tag_send_logs_req);

        req.execute(self.configuration.borrow())
    }

    fn get_user_friend_work_moments(&self, token: &str, base_info_get_user_friend_work_moments_req: Option<crate::models::BaseInfoGetUserFriendWorkMomentsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserFriendWorkMomentsResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/get_user_friend_work_moments".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_user_friend_work_moments_req);

        req.execute(self.configuration.borrow())
    }

    fn get_user_in_department(&self, token: &str, base_info_get_user_in_department_req: Option<crate::models::BaseInfoGetUserInDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserInDepartmentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/get_user_in_department".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_user_in_department_req);

        req.execute(self.configuration.borrow())
    }

    fn get_user_req_group_application_list(&self, token: &str, base_info_get_user_req_group_application_list_req: Option<crate::models::BaseInfoGetUserReqGroupApplicationListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetGroupApplicationListResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/get_user_req_group_applicationList".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_user_req_group_application_list_req);

        req.execute(self.configuration.borrow())
    }

    fn get_user_tag_by_id(&self, token: &str, base_info_get_user_tag_by_id_req: Option<crate::models::BaseInfoGetUserTagByIdReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserTagByIdResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/get_user_tag_by_id".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_user_tag_by_id_req);

        req.execute(self.configuration.borrow())
    }

    fn get_user_tags(&self, token: &str, base_info_get_user_tags_req: Option<crate::models::BaseInfoGetUserTagsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserTagsResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/get_user_tags".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_user_tags_req);

        req.execute(self.configuration.borrow())
    }

    fn get_user_work_moments(&self, token: &str, base_info_get_user_work_moments_req: Option<crate::models::BaseInfoGetUserWorkMomentsReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUserWorkMomentsResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/get_user_work_moments".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_user_work_moments_req);

        req.execute(self.configuration.borrow())
    }

    fn get_users_info(&self, token: &str, base_info_get_users_info_req: Option<crate::models::BaseInfoGetUsersInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUsersInfoResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/user/get_users_info".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_users_info_req);

        req.execute(self.configuration.borrow())
    }

    fn get_users_online_status(&self, token: &str, base_info_get_users_online_status_req: Option<crate::models::BaseInfoGetUsersOnlineStatusReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetUsersOnlineStatusResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/user/get_users_online_status".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_users_online_status_req);

        req.execute(self.configuration.borrow())
    }

    fn get_work_moment_by_id(&self, token: &str, base_info_get_work_moment_by_id_req: Option<crate::models::BaseInfoGetWorkMomentByIdReq>) -> Box<dyn Future<Item = crate::models::BaseInfoGetWorkMomentByIdResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/get_work_moment_by_id".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_get_work_moment_by_id_req);

        req.execute(self.configuration.borrow())
    }

    fn import_friend(&self, token: &str, base_info_import_friend_req: Option<crate::models::BaseInfoImportFriendReq>) -> Box<dyn Future<Item = crate::models::BaseInfoImportFriendResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/import_friend".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_import_friend_req);

        req.execute(self.configuration.borrow())
    }

    fn invite_user_to_group(&self, token: &str, base_info_invite_user_to_group_req: Option<crate::models::BaseInfoInviteUserToGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoInviteUserToGroupResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/invite_user_to_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_invite_user_to_group_req);

        req.execute(self.configuration.borrow())
    }

    fn is_friend(&self, token: &str, base_info_is_friend_req: Option<crate::models::BaseInfoIsFriendReq>) -> Box<dyn Future<Item = crate::models::BaseInfoIsFriendResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/is_friend".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_is_friend_req);

        req.execute(self.configuration.borrow())
    }

    fn join_group(&self, token: &str, base_info_join_group_req: Option<crate::models::BaseInfoJoinGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoJoinGroupResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/join_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_join_group_req);

        req.execute(self.configuration.borrow())
    }

    fn kick_group_member(&self, token: &str, base_info_kick_group_member_req: Option<crate::models::BaseInfoKickGroupMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoKickGroupMemberResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/kick_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_kick_group_member_req);

        req.execute(self.configuration.borrow())
    }

    fn like_one_work_moment(&self, token: &str, base_info_like_one_work_moment_req: Option<crate::models::BaseInfoLikeOneWorkMomentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoLikeOneWorkMomentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/like_one_work_moment".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_like_one_work_moment_req);

        req.execute(self.configuration.borrow())
    }

    // fn management_batch_send_msg(&self, token: &str, UNKNOWN_BASE_TYPE: Option<crate::models::UNKNOWN_BASE_TYPE>) -> Box<dyn Future<Item = crate::models::BaseInfoManagementBatchSendMsgReq, Error = Error<serde_json::Value>>> {
    //     let mut req = __internal_request::Request::new(hyper::Method::Post, "/msg/batch_send_msg".to_string())
    //     ;
    //     req = req.with_header_param("token".to_string(), token.to_string());
    //     req = req.with_body_param(UNKNOWN_BASE_TYPE);

    //     req.execute(self.configuration.borrow())
    // }

    // fn management_send_msg(&self, token: &str, UNKNOWN_BASE_TYPE: Option<crate::models::UNKNOWN_BASE_TYPE>) -> Box<dyn Future<Item = crate::models::BaseInfoManagementSendMsgResp, Error = Error<serde_json::Value>>> {
    //     let mut req = __internal_request::Request::new(hyper::Method::Post, "/msg/manage_send_msg".to_string())
    //     ;
    //     req = req.with_header_param("token".to_string(), token.to_string());
    //     req = req.with_body_param(UNKNOWN_BASE_TYPE);

    //     req.execute(self.configuration.borrow())
    // }

    fn minio_upload_file(&self, token: &str, file: std::path::PathBuf, file_type: i32, operation_id: &str) -> Box<dyn Future<Item = crate::models::BaseInfoMinioUploadFileResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/third/minio_upload".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_form_param("file".to_string(), unimplemented!());
        req = req.with_form_param("fileType".to_string(), file_type.to_string());
        req = req.with_form_param("operationID".to_string(), operation_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn mute_group(&self, token: &str, base_info_mute_group_req: Option<crate::models::BaseInfoMuteGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoMuteGroupResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/mute_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_mute_group_req);

        req.execute(self.configuration.borrow())
    }

    fn mute_group_member(&self, token: &str, base_info_mute_group_member_req: Option<crate::models::BaseInfoMuteGroupMemberReq>) -> Box<dyn Future<Item = crate::models::BaseInfoDismissGroupResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/mute_group_member".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_mute_group_member_req);

        req.execute(self.configuration.borrow())
    }

    fn parse_token(&self, token: &str, base_info_parse_token_req: Option<crate::models::BaseInfoParseTokenReq>) -> Box<dyn Future<Item = crate::models::BaseInfoParseTokenResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/auth/parse_token".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_parse_token_req);

        req.execute(self.configuration.borrow())
    }

    fn quit_group(&self, token: &str, base_info_quit_group_req: Option<crate::models::BaseInfoQuitGroupReq>) -> Box<dyn Future<Item = crate::models::BaseInfoQuitGroupResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/quit_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_quit_group_req);

        req.execute(self.configuration.borrow())
    }

    fn remove_black(&self, token: &str, base_info_remove_black_list_req: Option<crate::models::BaseInfoRemoveBlackListReq>) -> Box<dyn Future<Item = crate::models::BaseInfoRemoveBlackListResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/remove_black".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_remove_black_list_req);

        req.execute(self.configuration.borrow())
    }

    fn send_msg2_tag(&self, token: &str, base_info_send_msg2_tag_req: Option<crate::models::BaseInfoSendMsg2TagReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSendMsg2TagResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/send_msg_to_tag".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_send_msg2_tag_req);

        req.execute(self.configuration.borrow())
    }

    fn set_friend_remark(&self, token: &str, base_info_set_friend_remark_req: Option<crate::models::BaseInfoSetFriendRemarkReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetFriendRemarkResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/friend/set_friend_remark".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_set_friend_remark_req);

        req.execute(self.configuration.borrow())
    }

    fn set_global_recv_message_opt(&self, token: &str, base_info_set_global_recv_message_opt_req: Option<crate::models::BaseInfoSetGlobalRecvMessageOptReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetGlobalRecvMessageOptResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/user/set_global_msg_recv_opt".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_set_global_recv_message_opt_req);

        req.execute(self.configuration.borrow())
    }

    fn set_group_info(&self, token: &str, base_info_set_group_info_req: Option<crate::models::BaseInfoSetGroupInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetGroupInfoResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/set_group_info".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_set_group_info_req);

        req.execute(self.configuration.borrow())
    }

    fn set_group_member_info(&self, token: &str, base_info_set_group_member_info_req: Option<crate::models::BaseInfoSetGroupMemberInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetGroupMemberInfoResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/set_group_member_info".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_set_group_member_info_req);

        req.execute(self.configuration.borrow())
    }

    fn set_tag(&self, token: &str, base_info_set_tag_req: Option<crate::models::BaseInfoSetTagReq>) -> Box<dyn Future<Item = crate::models::BaseInfoSetTagResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/office/set_tag".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_set_tag_req);

        req.execute(self.configuration.borrow())
    }

    fn transfer_group_owner(&self, token: &str, base_info_transfer_group_owner_req: Option<crate::models::BaseInfoTransferGroupOwnerReq>) -> Box<dyn Future<Item = crate::models::BaseInfoTransferGroupOwnerResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/group/transfer_group".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_transfer_group_owner_req);

        req.execute(self.configuration.borrow())
    }

    fn update_department(&self, token: &str, base_info_update_department_req: Option<crate::models::BaseInfoUpdateDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUpdateDepartmentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/update_department".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_update_department_req);

        req.execute(self.configuration.borrow())
    }

    fn update_organization_user(&self, token: &str, base_info_update_organization_user_req: Option<crate::models::BaseInfoUpdateOrganizationUserReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUpdateOrganizationUserResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/update_organization_user".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_update_organization_user_req);

        req.execute(self.configuration.borrow())
    }

    fn update_user_in_department(&self, token: &str, base_info_update_user_in_department_req: Option<crate::models::BaseInfoUpdateUserInDepartmentReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUpdateUserInDepartmentResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/organization/update_user_in_department".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_update_user_in_department_req);

        req.execute(self.configuration.borrow())
    }

    fn update_user_info(&self, token: &str, base_info_update_self_user_info_req: Option<crate::models::BaseInfoUpdateSelfUserInfoReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUpdateUserInfoResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/user/update_user_info".to_string())
        ;
        req = req.with_header_param("token".to_string(), token.to_string());
        req = req.with_body_param(base_info_update_self_user_info_req);

        req.execute(self.configuration.borrow())
    }

    fn user_register(&self, base_info_user_register_req: Option<crate::models::BaseInfoUserRegisterReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUserRegisterResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/auth/user_register".to_string())
        ;
        req = req.with_body_param(base_info_user_register_req);

        req.execute(self.configuration.borrow())
    }

    fn user_token(&self, base_info_user_token_req: Option<crate::models::BaseInfoUserTokenReq>) -> Box<dyn Future<Item = crate::models::BaseInfoUserTokenResp, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/auth/user_token".to_string())
        ;
        req = req.with_body_param(base_info_user_token_req);

        req.execute(self.configuration.borrow())
    }

}
